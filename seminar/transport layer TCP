신뢰적인 데이터 전송의 원리

일반적인 상황에서의 신뢰적인 데이터 전송 문제

신뢰적인, reliable 한 데이터 전송을 구현하는 문제는 transport layer 뿐 아니라 link layer, application layer 에도 발생할 수 있는 문제.

네트워킹에서 진짜 중요하다

네트워킹에서 기본적으로 중요한 문제의 상위 10개를 꼽는다면 리스트에서 젤 먼저 선택될 정도

1. 신뢰적인 채널에서는 전송된 데이터가 변형되거나 손실되지 않는다
2. 모든 데이터는 전송된 순서대로 전달된다.

위 두가지가 TCP가 인터넷 애플리케이션에 제공하는 서비스 모델이다.

이러한 서비스 추상화를 구현하는 것이 reliable data transfer protocol (신뢰적인 데이터 전송 프로토콜) 의 의무

이 작업이 어려운 까닭은 신뢰적인 전송 프로토콜의 아래에 있는 계층이 신뢰적이지 않으므로 어렵다
TCP를 예로 들면 아래 계층은 비신뢰적인 IP 의 바로 상위에 구현된 신뢰적인 데이터 전송 프로토콜이다

==================================================
rdt2.0
비트 오류가 있는 채널에서의 신뢰적인 데이터 전송

1. 만약 패킷안의 비트들이 하위 채널에서 변형됐다고 쳐보자
비트 오류는 패킷이 전송 또는 전파되거나 버퍼링 될 때 네트워크의 물리적 구성요소에서 일반적으로 발생한다

2. 단 전송된 모든 패킷이 송신된 순서대로(패킷의 비트가 변형된다고 하더라도) 수신된다고 가정

이러한 채널에서 신뢰적인 통신을 위해

긍정 확인 응답(positive acknowledment)
부정 확인 응답(negative acknowlegment)

을 사용한다.

그냥 알기 쉽게 잘 알아들었으면 긍정확인응답(OK), 잘 못알아들었으면 부정확인응답(다시 말해주십쇼)
-> 이렇게 재전송 하는거다
이러한 "제어 메시지"는 정확하게 수신되었는지 또는 잘못 수신되어 반복이 필요한지
수신자가 송신자에게 알려줄 수 있게 한다.

컴퓨터 네트워크 설정에서 이런 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은
-> ARQ (Automatic Repeat reQuest; 자동 재전송 요구) 프로토콜로 알려져 있다

-> 비트 오류를 처리하기 위해 기본적으로 다음과 같은 세가지 부가 프로토콜 기능이 ARQ 프로토콜에서 요구 된다

1. 오류 검출

UDP header 의 checksum filed 의 역할 송신자로부터 수신자에게 전송되는 여분의 비트들을 요구한다 
이러한 비트는 데이터 패킷의 패킷 검사합 필드로 모아질 것이다

2. 수신자 피드백

송신자가 수신자의 상태를 알기 위한 유일한 방법은 수신자가 직접 송신자에게 피드백을 제공하는 것
이 시나리오에서 긍정 확인응답, 부정확인응답이 그 예다. 
이 시나리오에서 수신자는 송신자에게 ACK or NAK 패킷을 전송할 것. 보통 1비트면 된다

3. 재전송

수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해서 재전송된다


ACK NAK 필드도 변형될수 있다

이에 sequence number 라는 필드를 삽입한다
간단히 데이터 패킷에 송신자가 번호를 붙이는 것

송신자가 ACK NAK 비트가 변형되었을 때 패킷을 재전송을 할것이다
그렇다면 수신자측에서도 재전송된건지 새 패킷인지 알아야하니 sequence number를 붙여 가장 최근에 보낸 패킷의 시퀀스 번호와 같다면 재전송, 아니라면 (moduler-2 연산) 새로운 패킷임을 알수 있는것

송신자는 패킷이 손실되었다는 것을 확신하기 위해 적어도 왕복시간 지연(라우터 버퍼링 포함) + 수신측에서 패킷을 처리하는데 필요한 시간 
만큼 기다린다, 최악의 경우만큼 지연을 기다리는것 

만일 ACK 가 수신되지 않는다면 패킷은 재전송된다
duplicate data packet 의 가능성이 있지만 sequence number 라는 대비책이 있다

송신자의 입장에서 재전송은 신이고 무적이다 
송신자는 데이터 패킷이 손실되었는지, ACK 가 손실되었는지, 지연되었는지 알지 못한다 
알더라도 그냥 재전송밖에 할 수 있는게 없다

시간 기반의 재전송 메커니즘을 구현 하려면 주어진 시간이 경과한 후에 송신자를 interrupt 할 수 있는 카운트 다운 타이머가 필요하다

1. 패킷이 송신된 각각의 시간에 타이머를 시작
2. 타이머 인터럽트에 반응
3. 타이머 정지

round-trip delay, Rount Trip Time( 왕복 지연, 왕복 시간) RTT 라고 함

pipelining 

전송 후 대기 하지않고(ACK 패킷을 하나하나 기다리지않고) 
확인응답을 기다리기 전 패킷을 먼저 보내는것

1. sequence number 의 범위는 증가되어야 한다. 각각 전송중인 패킷은 유일한 순서번호를 가져야하고 거기에 전송 중이고 확인응답이 안된 여러 패킷이 있을 수 있다

2. 프로토콜으ㅏ 송신측과 수신측은 한 패킷 이상을 버퍼링 해야 한다. 최소한 송신자는 전송되었으나 확인응답이 되지 않은 패킷을 버퍼링해야 할것이다

GBN은 가장 오래된 패킷에 대해 단일 타이머를 실행한다

TCP

full-duplex service

point to point

end to end

소켓을 통해 데이터의 스트림을 전달

세그먼트의 크기는 MSS, Maximum Segment Size 로 제한

MSS 는 일반적으로 MTU(Maximum Transmission unit) 에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이를 결정

TCP 세그먼트(IP 데이터그램 안에 캡슐화된) 가 단일 링크 계층 프레임으로 맞춰지도록 MSS 를 설정

MSS 는 TCP의 구현(OS에 따라 달라짐) 에 따라 일반적으로 1460, 536, 512 바이트다

MSS 는 헤더를 포함한 TCP 세그먼트의 최대크기가 아닌, 세그먼트에서 애플리케이션 계층 데이터에 대한 최대 크기
책에 이상하게 나왔는데 그냥 헤더 필드와 데이터 필드중에 데이터 필드 크기를 제한한다는 것

TCP는 TCP 헤더와 클라이언트 데이터를 하나로 만들어 TCP 세그먼트를 형성


일반적으로 TCP 헤더는 UDP 보다 12바이트 큰 20바이트

TCP 또한 UDP 처럼, 헤더는 상위계층 애플리케이션으로부터 multiflexing, de-multiflexing 하는 데 사용하는 근원지와 목적지 포트번호를 포함한다

또한 UDP 처럼 checksum field 를 포함한다


32 bit sequence number field
32 bit acknowledgment number field
위 두 필드는 신뢰적인 데이터 전송 서비스 구현에서 TCP 송신자와 수신자에 의해 사용

16 bit receive window field 
flow control 에 사용된다. 수신자가 받아들이는 바이트의 크기를 나타내는 데 사용된다는 것

4  bit header lenght field
32bit word 단위로 TCP header 의 길이를 나타낸다. TCP 헤더는 이전에 논의한 TCP 옵션필드 때문에 가변적인 길이가 될수도 있다

option field 는 가변적인 길이. 송신자와 수신자가 MSS 를 협상하거나 고속 네트워크에서 사용하기 위한 window 확장 요소로 사용, time stamp option 또한 정의된다

6bit flag field

ACK 비트는 acknowkledgment number field 에 있는 값이 유용함을 가르킨다 (확인 응답을 포합한다)
RST, SYN, FIN 비트는 연결 설정과 해제에 사용된다
PSH 비트는 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킨다
URG 비트는 세그먼트에서 송신측 상위 계측 개체가 긴급으로 표시하는 데이터임을 가르킨다

긴급 데이터의 마지막 바이트의 위치는 16bit 의 urgent data pointer field (긴급 데이터 포인터 필드) 에 의해서 가르켜진다

타임아웃 주기가 비교적 길어질 수 있다 

TCP는 송신자가 수신자의 버퍼를 오버플로 시키는 것을 방지하기 위해 flow control service 를 제공하며 flow control 은 송신자가 송신하는 속도와 수신자의 application 이 버퍼를 읽는 속도를 일치 시키는 것

flow control 과 congestion control 은 수행하는 동작(송신자를 억제) 이 비슷하지만 엄연히 목적이 다르다

2008년도에는 저자들이 용어를 혼용해서 썼다고 한다    

flow control 은 receive window 그거 16bit 짜리로 하는거고

congestion control 이 중요

TCP 는
종단 간 혼잡 제어을 한다. 그니까 네트워크 혼잡에 따라 연결 트래픽을 보내는 전송률을 각 송신자가 제어한다

1. TCP 송신자는 자신의 연결에 송신자 전송 트래픽을 어떻게 제한하는가
2. TCP 송신자는 자신과 목적지 사이 경로의 혼잡을 어떻게 감지하는가
3. 송신자는 종단 간의 혼잡을 감지함에 따라 송신율을 변화시키기 위해 어떤 알고리즘을 사용하는가

TCP Reno 혼잡 경로 알고리즘

TCP 연결은 각각 수신버퍼, 송신버퍼, 몇 가지 변수들로 구성된다 
TCP 혼잡은 연결의 양 끝이 추가적인 변수인 congestion window 가 추적하도록 한다

CongWin으로 표시되는 혼잡 윈도우는 TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 비율을 제한한다 
송신 측에서 확인 응답이 안된 데이터의 양은 ConWin과 RcvWindow 의 최솟값을 초과하지 않는다

Rcvwindow 재끼고 Conwin 만 따졌을때 송신자의 송신률은 

conwin/RTT byte/sec




