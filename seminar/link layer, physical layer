링크 계층

communication path

source host -> router -> destination host

종단 간 통신 경로상의 링크로 패킷을 전송하는 법
어떻게 데이터그램을 프레임으로 캡슐화 하는가 

링크 계층 프로토콜이 라우터들 간에 신뢰적인 데이터 전달을 해주는지

링크 계층 프로토콜은 근본적으로 다른 두가지 프로토콜이 존대

broad cast, point-to-point

브로트캐스트 채널은 일반적으로 근거리 네트워크나 무선 랜, 위성 네트워크등 액세스 네트워크에서 사용된다
다수의 호수트가 동일한 통신링크에 연결되며 호스트간의 충돌을 방지, 전송을 조절하는 media access protocol 이 
요구된다

ptp 통신 링크는 두라우터 또는 주택의 다이얼업 모뎀과 ISP 라우터 간 사용될 수도 잇다
ptp 통신 링크에서의 접근 제어는 쉽지만 프레임화나 신뢰적인 데이터전달, 오류 검출, 흐름제어들은 여전히 중요하다

=====
L2 에서는 호스트와 라우터를 단순히 노드라 한다
통신 경로상 인접한 노드들을 연결하는 통신 채널은 링크 라고 한다
데이터그램을 근원지 호스트에서 목적지 호스트로 이동하기 위해서는 데이터그램을 종단 간 경로의 개별 링크로 이동시켜야한다
전송노드는 데이터그램을 링크 계층의 프레임으로 캡슐화해서 링크로 전송한다. 그리고 수신 노드는 프레임을 받아
데이터 그램을 추출해낸다

===============
link layer protocol 은 링크 양단에 있는 노드들 사이에 교환되는 패킷 (PDU) 형식과 패킷 송수신시 노드가 취하는 행동에 대해 정의

링크 계층 프로토콜에 의해 교환되는 데이터단위를 프레임이라 한다 (frame) 


링크계열 프로토콜은 영향을 미치지않느다

링크 계층의 기본 서비스는 단일 통신 링크상으로 데이터그램을 한 노드에서 인접 노드로 이동 시키는것
서비스의 세부사항은 링크에 적용되는 특정 링크 계층 프로토콜에 따름

링크 계층 프로토콜이 제공할 수 있는 서비스는 아래와 같다

프레임화 : 거의 모든 링크 계층 프로토콜은 네트워크 계층 데이터그램을 링크상으로 전송하기 전에 링크 계층 프레임에 캡슐화한다. 프레임은 네트워크 계층 데이터그램이 들어있는 데이터 필드와 여러개 의 헤더 필드로 구성된다
(프레임은 trailer 필드를 포함할수도 있다{tail field}) 프레임 구조는 데이터 링크 프로토콜에 의해 명시된다

링크 액세스 : MAC(medium access control) 매체 액세스 제어 프로토콜은 링크 상으로 프레임을 전송하는 규칙에 대해 명시한다
링크의 한쪽 끝에 단일 송신자와 다른 쪽 끝에 단일 수신자가 있는 점대점 링크의 경우 MAC 프로토콜은 단순하다(없을 수도) 송신자는 링크가 idle 할때마다 프레임을 전송할수 있다. 한 브로드캐스트 링크를 여러 노드가 공유하는 경우(다중 액세스 문제) 복잡하다

통신용 어댑터

대부분 링크 계층 프로토콜은 통신 링크에서 adapter에서 구현된다
보통 어댑터는 RAM, DSP 칩, Host bus interface, link interface board(PCMCIA card)
어댑터는 Network Interface Card 라고도 불린다 -> NIC


어댑터는 semi autonomous 한 장치

어댑터는 데이터그램을 프레임에 캡슐화한 후 이 프레임을 통신 링크로 전송한다.
그럼 상대방 어댑터가 프레임을 수신해서 네트워크 계층 데이터그램을 전달한다

프로토콜이 오류 검출을 한다면 오류 검출 비트 설정은 송신 어댑터가 하고 오류검사는 수신 어댑터가 한다.
프로토콜이 신뢰적전달을 제공한다면 전적으로 어댑터에서 구현된다. 
프로토콜이 랜덤 액세스을 제공한다면 이것도 모두 어댑터에서 구현된다.

어댑터는 프레임을 수신해서 오류가 있는지 결정한후 부모 노드안의 구성 요소에게 알리지 않고 그 프레임을 폐기 할 수도 있다.
프레임을 수신한 어댑터는 네트워크 계층 데이터그램을 프로토콜 스택의 위쪽으로 전달할 때만 (오류 없고 다 좋을때)
부모 노드를 interrupt 한다
부모 노드가 데이터그램을 프로토콜 스택의 아래쪽으로 어댑터에게 전달하면 데이터그램을 링크로 전송하는 일을 어댑터에 맡긴다

하지만 반자치적인 장치다 결국은 부모 노드에 의해 제어된다

어댑터의 주요 구성요소는 버스 인터페이스와 링크 인터페이스다

버스 인터페이스는 부모 노드와 어댑터의 통신을 담당하며 제어 정보 및 데이터를 전달한다

링크 인터페이스는 링크 계층 프로토콜을 구현하는 일을 담당하며 
데이터그램의 프레임화 및 역프레임화
오류검출, 랜덤 액세스 및 기타 링크 계층 기능을 제공

링크 인터페이스는 송신 및 수신 회로를 가지고 있다

한 노드에서 물리적으로 연결된 이웃노드로 전송한 링크 계층 프레임 안의 비트 오류 검출과 정정

"비트 수준 오류 검출과 정정" (bit level error detection and correction) 은 데이터 링크 계층에서 제공하는 
대표적인 두 가지 서비스중 하나

비트 수준이다. 몇가지 굉장히 단순한 기술 일부를 알아본다

오류 검출 비트 설정은 송신 어댑터에서 진행한다고 했다. 근데 어차피 노드안에 포함된 장치니 노드에서 한다고 하겠다
송신 노드는 데이터에 오류 검출 및 정정 비트들 (EDC) 를 첨가한다
네트워크 계층에서 내려온 데이터 그램뿐아니라 데이터 링크 프레임 헤더에 있는 필드들도 포함한다

수신자는 자신이 수신한 데이터와 EDC 만으로 원래 데이터와 수신된 데이터가 동일한지 결정해야한다

수신자는 오류검출과 정정 기술을 사용해 (항상은 아니지만) 비트 오류를 검출한다
근데 못할 수도 있다, 오버헤드와 정확도는 대부분 정비례한다

그래서 기법선택이 중요하다
그중 3가지 기술
패리티 검사
검사합
순환중복 검사

가장 단순한 형태의 오류 검출은 단일 패리티 비트의 사용이다
데이터가 d 비트를 가지고 있다고 가정하자. 짝수 패리티 기법은 사용자가 단순히 한 비트를 추가하고
그 비트 값을 d + 1게의 비트들 에서 1의 개수가 짝수가 되도록 선택한다 

홀수 패리티 기법은 뭐 1이 홀수가 되게한다

이렇게 단순하니 수신자도 따로 복잡하진 않다

수신자는 수신된 d+1 개의 비트에서 1의 개수를 계산하면된다 (그냥 세는거다)

짝수 패리틴데 홀수면 최소한 하나는 비트오류가 있는거다
정확히는 홀수 개의 비트 오류가 발생했다는걸 알수 있다

근데 짝수 비트 오류가 발생하면? 당연히 검출 못한다. 
보통 오류는  burst 형태로 한꺼번에 몰려오는데 이러면 패리티로 보호되는 프레임에서 미검출 오류가 있을 확률은 
반밖에 안될수 도 있다

당연히 단일 패리티같은건 안쓰고 딴거 더 좋은거 사용한다

단순하게 이차원으로 일반화 해보자

d 비트는 i개 의 행과 j개의 열로 나뉜다. 각각 행과 열에 대해 하나의 패리티 값이 계산된다
이차원으로 하나씩 패리티값이 추가되는것. 그럼 i+j+1 개의 패리티 비트는 아까보단 낫지 않겠나

이제 오류가 발생하면 수신자는 단일 비트 오류의 발생을 검출 할수 있을뿐 아니라,
열과 행의 인덱스를 사용해 잘못된 비트를 식별한담에 정정까지 가능하다(비트 단위니까 or 만해주면 됨)

그리고 정정은 못하지만 2개의 오류도 검출할 수 있다

오류를 검출 및 정정하는 능력을 Forward error correction 이라고 하는데 순방향 오류 정정이라고 할 수있겠다

FEC 라고 한다

네트워크 환경에서 FEC는 위처럼 단독으로 또는 ARQ랑 같이 사용할수 있다
FEC는 송신자에게 재전송 횟수를 줄일수 있다는 것에 큰 의의가 있다. 
NAK 패킷 주고 다시 왕복 전파 지연 시간을 기다리지 않아도 된다는 것

이제 계속 나온 checksum 방법이다 

데이터를 구성하는 d비트를 일련의 k비트 정수들처럼 다룬다는데 구현방법이 가지각색일거다 
그냥 internet checksum. 전부 더해서 1의 보수만 기억하자
이건 딱 보면 알수 있다시피 오버헤드가 작다.

그래서 정확도는 좀 떨어진다. 근데 이걸 쓸필요가 없다 우리 링크 계층은 어댑터 내부 전용하드웨어로 구현이 가능해
좀더 복잡한 연산도 가능하기 때문
이건 소프트웨어로 굴리는 트랜스포트 레이어에 양보하고 링크계층은 복잡하지만 확실한 CRC를 사용하자

CRC. 오늘날(2008년) 컴퓨터 네트워크에서 널리 사용되는 오류 검출 기술이다

cyclic redundancy check, 직역하면 순환 중복 검사인데 CRC 코드는 다항식 코드로도 알려졌다고 한다

전송되는 비트열에 있는 0과 1을 계수로 갖는 다항식처럼 비트열을 생각할 수 도 있고 비트열에 적용되는 연산을 
다항식 연산으로 이해하는 것이 가능하기 때문

아직 잘모르겠다

CRC 코드는 d 비트로 이루어진 데이터 D를 송신할때

송신자와 수신자는 G로 표기되는 generator(생성자) 로 알려진 r+1 비트 패턴에 대해 합의한다
symmetic cipher 처럼 일단 비트 패턴 입을 맞춰놓는거다
무결성을 검증하진 못한다


나머지는 구글에 CRC 쳐보자

다중 액세스 프로토콜

브로드캐스트링크에는 동일한 하나의 공유된 브로드캐스트 채널에 다수의 송신 노드 및 수신 노드들이 연결된다
임의의 한노드가 프레임을 전송하면 채널이 그 프레임을 복사해 다 뿌린다

이더넷과 무선랜이 브로드캐스트 링크 기술의 대표 예다. 중요하다고 할 수 있겠다.

데이터 링크 계층에서 가장 중요한 문제는 위에서 봤던 오류 검출 정정 뭐 FEC, CRC 이런게 아니다
젤 중요한건 다중 액세스 문제(multiple access problem) 
이게 뭐냐면 한마디로 다수의 송수신노드들에게 공유되는 브로드캐스트 채널로 접속을 컨트롤하는 것.

집에 있는 텔레비전이 단방향 브로드캐스트, 컴퓨터 네트워크의 브로드캐스트 채널에 있는 노드들은 방송을 보기만 하는게 아니라 송수신을 할 수 있다는 차이빼고는 똑같다

노드 하나가 송신했다고 항상 노드 전부한테 뿌리긴 좀 그렇지 않을까
"공유되는" 브로드캐스트 채널로 보내는 노드들의 전송을 조정하기 위한 다중 액세스 프로토콜이 있는것

이건 유선이든 무선이든 위성이든 다양한 네트워크 설정에서 필요하다.
기술상 노드가 자신의 어댑터를 통해 브로드캐스트 채널에 접속하지만 여기선 송신 장치나 수신 장치라고 한다

모든 노드들은 프레임을 전송할 수 있다
그 말은 즉슨 두개 이상의 노드가 프레임을 전송할 수 있다
그러면 어떻게 될까 링크는 한정되있고 동시에 여러개의 프레임이 꽂히면 각 수신자에서 프레임들이 
충돌 (collide) 한다
충돌나면 프레임은 엉망이 된다. 해석 못한다 아무도

초당 R 비트의 전송률을 갖는 브로드캐스트 채널에 대한 multiple access protocol 은 

1. 하나의 노드가 전송할 데이터가 있을 때 그 노드는 R bps의 처리율을 갖는다
2. M개의 노드가 전송할 데이터가 있을 때는 각 노드가 R/M의 bps 의 처리율을 갖는다
3. 프로토콜은 분산되어 고장으로 전체 시스템을 정지시키는 마스터 노드가 없다
4. 단순하고 비용이 적게 든다

채널 분할 프로토콜

채널을 공유하는 모든 노드가 브로드캐스트 채널의 대역폭을 분할할 수 있게 해주는 두 가지 기술인 시분할 다중화(TDM) 주파수 분할 다중화 (FDM) 
채널이 N개의 노드를 지원하고 채널 전송률이 R bps 라고 하자.

TDM 은 시간을 시간프레임 (Time frame) 으로 나누고 또한 각 시간 프레임을 N개 시간 슬롯(time slot) 으로 나눈다
(데이터 링크 계층의 단위 프레임과 다르다)

각 시간 슬롯은 N개 노드에게 각각 할당된다. 노드는 전송할 패킷이 있을 때마다 TDM 프레임에서 자신에게 할당된 시간 슬롯 동안 패킷 비트들을 전송한다.
일반적으로 슬롯 크기는 한 패킷이 한 슬롯 시간 동안 전송될 수 있게 선택된다

제일 유명한 칵테일파티로 돌아가자
TDM 방식으로 조정되는 칵테일 파티에서는 파티 참석자 한 명이 고정된 시간동안 말할 수 있고, 그 뒤 또 다른 파티 참석자가 똑같은 시간동안 말할 수 있다. 
모든 사람에게 말할 기회가 주어진 다음에는 똑같은 패턴이 반복된다

TDM 은 충돌을 제거할 수 있고 아주 공정하므로 바람직하다 (각 노드는 프레임 시간 동안에 R/N bps의 할당된 전송률을 가진다)

두 가지 단점이 있다

1. 전송할 패킷이 있는 노드가 단 하나인 경우에도 노드 전송률이 평균 R/N 으로 제한된다
2. 노드가 전송 순서상 자신의 차례를 항상 기다려야한다


FDM은 R bps 의 채널을 다른 주파수(각 R/N의 대역폭을 갖는)로 나눠서 각 주파수를 N개 노드 중 하나에게 할당한다
그니까 FDM은 하나의 큰 R bps 채널로부터 N개의 R/N bps의 작은 채널을 만든다. 
FDM은 TDM 과 같은 장단점을 지닌다

전송할 노드가 단 하나일지라도 노드는 R/N 의 대역폭으로 한정된다

마지막 채널 분할 프로토콜은 코드 분할 다중 접속 (CDMA: Code division Multiple Access) 
CDMA 는 다른 코드를 노드에게 할당한다.
각 노드는 자신의 유일한 코드로 전송하는 데이터 비트들을 인코딩한다
CDMA 네트워크는 다른 노드들이 동시에 전송할 수 있고, 또한 다른 노드들에 의해서 전송이 간섭(interfere) 되더라도
각 수신자들이 송신자의 인코딩된 데이터 비트를 정확하게 수신할 수 있다
CDMA( 반전판 방해 (anti-jamming) 특성을 가짐) 는 오랫동안 군사 시스템에서 사용
무선 채널에 밀접하게 연관되어 있다


랜덤 액세스 프로토콜 

랜덤 액세스 프로토콜에서 전송 노드는 항상 채널의 전속력인 R bps 로 전송한다.
충돌이 생기면 충돌과 관련된 노드는 프레임이 충돌없이 전송될 때까지 자신의 프레임을 계속해서 재전송한다
그렇다고 충돌 직후 해당 프레임을 즉시 재전송하지 않고 프레임을 재전송하기 전에 랜덤 지연 시간 동안 기다린다.

충돌과 관련된 각 노드는 자신만의 랜덤 지연 시간을 스스로 선택한다.
충돌했던 노드 중 하나는 다른 노드가 선택한 지연 시간보다 충분히 작은 지연시간을 선택해 충돌 없이 자신의 프레임을 채널로 전송할 수 있다

슬롯 알로하

1. 모든 프레임은 정확히 L 비트로 구성된다
2. 시간은 L/R 초의 슬롯들로 나뉘어진다 (한 슬롯은 한 프레임 전송에 걸리는 시간과 같음)
3. 노드는 슬롯의 시작점에서만 프레임을 전송하기 시작한다
4. 각 노드는 언제 슬롯이 시작하는지 알 수 있게끔 동기화되어 있다
5. 한 슬롯에서 두 개 이상의 프레임이 충돌하면, 모든 노드는 그 슬롯이 끝나기 전에 충돌 발생을 알게 된다


CSMA

슬롯과 순수 알로하에서 노드가 전송ㅇ 여부를 결정하는 것은 브로드캐스트 채널에 액세스 되어 있는 다른 노드의 활성여부와 무관하다.
칵테일 파티에서 알로하 프로토콜은 다른 사람이 얘기하고 있는 것에 신경쓰지 않고 계속해서 수다를 떠는 무례한 파티 참여자와 유사

이건 좀 예의바르다

규칙은 두가지

1. 말하기 전에 듣는다 (carrier sensing -> back-off ; roof)

다른 사람이 말하고 있다면, 말이 끝날 때가지 기다린다. 네트워크에서는 이것을 캐리어 감지(carrier sensing) 이라고 한다
다른 노드가 프레임을 채널로 전송하고 있으면, 임의의 시간동안 기다린(back off) 뒤에 다시 채널을 감지한다
만일 채널이 쉬는 것으로 감지되면 노드는 프레임을 전송하기 시작한다
아니면 노드는 또 임의의 시간동안 기다린뒤 과정을 반복한다

2. 다른 사람이 동시에 말하기 시작했다면 말을 중단한다

네트워크에서는 이것을 충돌 검출 (collision detection) 이라 한다(송신 노드는 전송하면서 동시에 채널을 듣는다)
만일 다른 노드가 방해 프레임을 전송하고 있음을 검출하면, 자신의 전송을 중단하고 다음에 언제 전송할지 다른 프로토콜을 사용해 결정한다

이 두 규칙은 CSMA (carrier sense Multiple Access) 와 CSMA/CD(CSMA with Collision Detection) 프로토콜에 포함된다 

이더넷은 CSMA/CD 를 사용

순번 프로토콜 

다중 액세스 프로토콜에서 요구되는 두 가지 특성으로는

1. 단 하나의 노드만이 활성이면 그 노드가 R bps의 처리율을 가진다
2. M개의 노드가 활성이면 각 노드가 거의 R/M bps의 처리율을 가진다

알로하와 CSMA 프로토콜은 첫번째 특성은 지니나 두 번째 특성은 없다

그래서 등장한게 taking-turns protocol, 순번 프로토콜이다

이것도 랜덤 액세스 프로토콜 (알로하, CSMA) 처럼 수십 개가 있으며, 각각 변형이 존재한다

가장 중요한 두가지만 배운다

1. 폴링 프로토콜(polling protocol), 폴링 프로토콜은 은 노드들 중 하나를 마스터 노드로 지정한다
마스터 노드는 각 노드를 라운드 로빈 방식으로 폴링한다
-> 라운드 로빈 : 타임 쉐어링(시분할) 시스템을 위해 설계된 선점형 스케줄링, 프로세스 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum) 로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘
보통 시간 단위는 10ms ~ 100ms 정도, 시간 단위동안 수행한 프로세스는 준비 큐의 끝으로 밀려나게 된다, context switching 의 오버헤드가 큰 반면, 응답 시간이 짧아지는 장점이 있어 실시간 시스템에 유리

마스터 노드는 노드 1에게 노드 1이 최대로 보낼 수 있는 프레임 수에 대한 정보를 지닌 메시지를 발송

노드 1이 프레임들을 보낸 다음에 마스터 노드는 노드 2에게 노드 2가 최대로 보낼 수 있는 프레임 수를 알려준다
마스터 노드는 채널에 신호가 없는 것을 봄으로써 노드가 프레임 전송을 끝마쳤음을 결정할 수 있다

마스터 노드는 순환적으로 각 노드를 폴링하는 방식으로 이 과정을 계속한다

폴링 프로토콜은 충돌뿐만 아니라 랜덤 액세스 프로토콜의 단점인 빈 슬롯을 제거한다
-> 높은 효율

근데 단점이 존재

1. 폴링 지연( 노드가 전송할 수 있음을 알리는 데 걸리는 시간)

한 노드가 활성이면, 활성 노드가 프레임을 최대 개수만큼 보낼 때마다 마스터 노드는 비활성 노드들을 차례로 폴링해야 하므로, 활성 노드는 R pbs보다 작은 전송률로 전송하게 된다.

2. 마스터 노드가 고장나면 전체 채널이 동작하지 못하게 된다는것 (비분산적)

두번째 순번 (taking turns) 프로토콜은 토큰 전달 프로토콜 (token-passing protocol) 이다

이 프로토콜에는 마스터 노드가 없다

토큰(token) 이라고 알려진 작은 "특수 목적 프레임"이 정해진 순서대로 노드들 사이에서 주고받는다

노드 1은 항상 노드 2에게 토큰을 전송하며, 노드 3는 항상 노드3 에게 토큰을 전송하고, 노드 N 은 항상 노드 1에게 토큰을 전송한다

노드가 토큰을 수신하면, 전송할 프레임이 있을 때만 토큰을 붙잡는다
토큰을 수신했을 때 전송할 프레임이 있으면 프레임을 최대 개수까지 전송한 뒤 토큰을 다음 노드에 전달한ㄴ다
수건 돌리기처럼 진행한다, 당연히 분산방식이며 효율인 높다. 
아주 큰 문제는 노드 하나가 고장나면 채널이 올 스탑이다. 노드가 잘못해서 토큰을 놓아주지 않으면 회복절차가 실행되어야 한다


근거리 네트워크 Local Area Network

여러 종류의 브로드캐스트 채널에 서 다중 액세스 프로토콜이 사용된다. 
다중 액세스 프로토콜은 노드들이 공통의 주파수 스펙트럼으로 전송하는 위성 및 무선 채널에서도 사용되어왔다

인터넷으로의 케이블 접근을 위한 상향(upstream) 채널에서 사용되며 근거리 네트워크에서 많이 사용되고 있다

랜은 건물이나 캠퍼스와 같은 지리적으로 집중된 컴퓨터 네트워크
이런 인터넷 액세스에서 사용자 호스트는 랜상의 노드가 되며 랜은 라우터를 통해 인터넷으로의 접속을 제공한다

802.3 랜으로 알려진 이더넷이 랜덤 액세스 기반, 두번째 랜 기술은 토큰 전달 기술 이며, Token ring; IEEE 802.5 로 알려진 토큰링과 FDDI(Fiber Distributed Data Interface) 가 여기 포함된다.

토큰 전달 기술은 이더넷과 경쟁에서 상대적으로 열세다

토큰링 랜에서 랜의 N개의 노드들이 직접 링크에 의해서 링 형태로 연결된다.
토큰 전달 순서는 토큰링 토폴로지에 의해서 결정된다. 
노드가 토큰을 획득해서 프레임을 전송하면, 프레임은 전체 링을 따라 전달되며
가상의 브로드캐스트 채널을 형성한다

목적지 노드는 프레임이 전파됨에 따라 링크계층매체로부터 그 프레임을 수신해 읽는다
프레임을 전송한 노드는 링에서 프레임을 제거할 책임이 있는데
일단 FDDI는 MAN 을 포함하는 지리적으로 넓은 랜용으로 설계 되었다는걸 알아두자
그럼 목적지 노드에서 다시 송신 노드로 전달해서 제거하는 건 비효울적이다
그래서 FDDI 는 목적지 노드가 링에서 프레임을 제거하게한다 (읽고 태워버리는) 
정확히 말하면 FDDI 는 모든 노드가 전송된 모든 프레임을 수신하는게 아니다, 순수한 의미의 브로드캐스트 체널은 아니라는 것

링크 계층 주소체계

노드(호스트와 라우터들) 는 링크 계층 주소를 가진다.
4장에서 배운 것을 떠올리면 노드는 네트워크 계층 주소도 가진다

왜 두개 다 필요한지 궁금할 수 도 있다

일단 그렇다고 알아만 두고 MAC 주소함 알아보자

실제로 링크 계층의 주소를 가진 것은 노드가 아니라 노드의 어댑터다 (Network interface card)

링크 계층 주소는 랜 주소, 물리 주소 또는 MAC 주소로 알려져 있다 (6byte)
MAC 주소는 영구적이다 제조될때 어댑터 ROM에 저장됨

IEEE 기관은 MAC 주소공간을 관리한다
회사는 2^24 로 이뤄진 주소공간을 구입하고 나머지 2^24 의 공간을 할당한다

처음 말했듯이 어댑터가 프레임을 목적지 어뎁터로 전송할 때, 송신 어댑터는 프레임에 목적지 어댑터의 MAC 주소를 넣고, 그 프레임을 랜상으로 전송한다

만약 랜이 브로드캐스트 랜이라면, 프레임은 랜상의 모든 어댑터들에 의해서 수신되고 처리된다,
프레임을 수신한 각 어댑터들은 프레임 안의 목적지 MAC주소와 자신의 MAC 주소가 일치하는 지를 검사할 것이다

만약 일치한다면, 어댑터는 프레임에 포합된 데이터그램을 추출하고 그 데이터 그램을 부모 노드의 프로토콜 스택의 위쪽으로 전달한다

일치하지않는다면 네트워크계층 데이터그램을 프로토콜 스택의 위쪽으로 전달하지않고 그 프레임을 폐기한다

어댑터가 프레임을 수신하면 단지 목적지 노드의 어댑터만이 부모노드를 인터럽트할 수 있다

근데 어떤 송신어댑터는 랜상의 다른 모든 어댑터가 자신이 전송하는 프레임을 수신하고 처리하기를 원한다

이경우에 송신 어댑터는 프레임의 목적지 주소 필드에 특수한 MAC 브로드캐스트 주소를 넣는다
6바이트 주소를 사용하는 랜에서 (이더넷, 토큰 전달 랜) 브로드캐스트 주소는 48개의 1로된 비트열 FF:FF:FF:FF:FF:FF 다

계층을 독립적으로 유지하기 위해 MAC과 IP 주소는 독립적으로 필요하다

네트워크 계층 주소와 링크 계층 주소가 있으니 이들 주소 사이에 변환이 필요하다

인터넷에서 이것은 ARP(address resolution protocol) 이라고 한다

IP는 dotted-decimal 표기법으로 표현하고 MAC 주소는 16진 표기법으로 표현한다.

송신 노드의 ARP 모듈은 입력 값으로서 동일한 랜상의 임의의 IP 주소를 선택하고 대응되는 MAC 주소를 돌려준다

여러모로 ARP는 호스트네임을 IP 주소로 반환하는 DNS와 비슷하다.
근데 이 둘의 중대한 차이점 하나는 DNS가 인터넷의 임의의 장소에 있는 호스트의 호스트네임을 해결하는 반면

ARP는 동일한 랜상에 있는 노드의 IP 주소만을 해결한다
만일 강원도에 있는 노드가 경상도에 있는 노드의 IP 주소를 해결하기위해 ARP를 사용하면 ARP는 거품물고 쓰러질 것이다

ARP가 어떻게 동작하나

각 노드(호스트 or 라우터) 는 노드의 메모리 램에 ARP table 을 가지고 있다. 이 ARP 테이블은 IP 주소와 MAC 주소 간의 매핑 정보를 포함한다
이 ARP 테이블은 IP 주소와 MAC 주소간의 매핑 정보를 포함한다.
매핑나오면 그냥 테이블 있다보면 된다.

테이블은 각 매핑이 언제 삭제되는지 나타내는 TTL 값을 포함한다 Time to live 직관적이다

이 테이블에 서브넷상의 모든 노드에 대한 엔트리는 가지고 있지 않아도 된다
어떤 노드들은 엔트리가 있을 수도 없을 수도있다 일반적으로 있어봤자 20분이면 사라진다

이제 패킷함 보내보자
ARP 테이블에 엔트리가 있음 다행이지만 없다면 어쩔까

이때 송신 노드는 MAC 주소를 따기 위해 ARP 프로토콜을 사용한다. 먼저 송신 노드는 ARP 패킷이라는 특수 패킷을 구성한다

ARP 은 송 수신 IP 주소와 MAC 주소를 포함하는 필드를 가지고 있다.

감이 올것이다

ARP 질의패킷은 목적을 해결하려는 IP 주소에 대응되는 MAC 주소를 결정하기 위해 서브넷의 다른 모든 노드에게 질의하는 것이다

이제 왜 같은 랜상에서 밖에 ARP 가 안되는지 이해될것이다

그럼 보낼땐 MAC 주소 없는데 프레임을 어떻게 생성해서 만들까

그때 사용하는게 FF:FF:FF:FF:FF:FF 랜 브로드캐스팅 주소다. 여기로 패킷을 뿌리면 됨

어댑터는 ARP 패킷을 링크계층의 프레임에 캡슐화하고 프레임을 서브넷으로 전송한다

일치하는 노드는 무조건 딱 하나 나올텐데 그친구가 요구된 매핑 정보를 포함하는 응답 ARP 패킷을 돌려보내준다

그럼 질의 노드는 자신의 ARP 테이블을 갱신하고 꽁쳐놨던 IP 데이터그램(테이블 정보로 캡슐화한담에)을 전송한다




