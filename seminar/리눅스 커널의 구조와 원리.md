# 리눅스 커널의 구조와 원리







## 리눅스 소개와 전망



* 리눅스는 IT 아카데미, 대학 학부과정, 대학원 프로젝트 과제 등 정규 교육 과정으로 자리를 잡았다

  * 리눅스는 **IT 산업 전반에서 쓰는 운영체제** (휴대폰, 클라우드 서버, 네트워크 장비 등)

  * 네트워크, 브라우저, WAS 웹 애플리케이션, 보안 유틸리티 등 **수많은 프로그램이 리눅스 기반 환경에서 동작**

  * 리눅스는 오픈소스 기반 운영체제, 리눅스는

    * 하드웨어를 제어하는 리눅스 커널
    * 커널 위에서 실행되는 리눅스 유틸리티로 구성됨

    리눅스 커널과 대부분의 리눅스에서 실행되는 프로그램의 소스코드는 공개되어 있음

    * 운영체제 핵심 기능
    * 각종 보안 기술
    * 네트워크 패킷 통신
    * 각종 센서 드라이버
    * 메모리 시스템
    * CPU 아키텍쳐(ARM, x86): 익셉션, 인터럽트, 메모리 관리
    * 파일 시스템과 SD 카드

    위와 같은 기술들이 리눅스 시스템 프로그램이나 리눅스 디바이스 드라이버에 구현되어있으며

    소스코드가 공개되어 있어 분석을 통해 세부 동작 원리를 파악할 수 있다. 

    

---

### 왜 리눅스 커널을 배워야 하는가

> 사실 반드시 배울 필요는 없다
>
> 하지만 리눅스 고급 개발자 또는 엔지니어로 실력을 인정받고 오랫동안 리눅스 개발을 하고 싶다면 리눅스 커널은 반드시 배워야한다



#### 임베디드 리눅스 혹은 BSP(Board Support Package) 개발자로 디바이스 드라이버 개발을 맡고 있다면 리눅스 커널을 알아야한다.

* **디바이스 드라이버는 커널 함수를 호출하는 방식으로 구현되 있기 때문이다**

  c프로그래밍에서 라이브러리 함수의 용법을 잘 알아야 한다

  그와 같이 디바이스 드라이버 개발을 잘 하려면 커널이 제공하는 함수의 동작 원리를 파악하고 있어야 한다.

  > 임베디드 리눅스, BSP 벤더에서는 리눅스 커널을 직무 교육과정으로 운영하는 경우가 많다





#### 고급 리눅스 시스템 프로그래머가 되려면 리눅스 커널을 알아야 한다.

리눅스 시스템 프로그램에서 사용하는 함수는

+ open(), read(), write(), close()   : 파일 처리 관련 함수
+ fork(), getpid(), exit()                  : 프로세스 처리 관련 함수
+ sigaction(), pause()                     : 시그널 처리 관련 함수



**위의 함수를 호출 할 시 리눅스 라이브러리의 도움으로 POSIX 시스템 콜을 호출해 커널이 동작한다**

리눅스 시스템 프로그램에서 시스템콜 함수를 호출시 에러가 발생했다면 **커널에서 에러 코드를 반환한 것이다**

**리눅스 시스템 프로그램을 실행하는 주체는 커널이다** 따라서 커널을 배우면 리눅스 시스템 프로글매의 세부 동작 원리를 알 수 있다.



#### 운영체제의 핵심 원리를 소스코드 분석으로 배울 수 있다



* CPU 아키텍쳐(ARM, x86): 익셉션, 인터럽트, 메모리관리
* 스케쥴링
* 시스템 콜
* 시그널
* 가상 파일 시스템 
* 메모리 관리

위와 같은 커널의 핵심 구현 원리를 소스코드 분석을 통해 배울 수 있다.



커널 디버깅과 커널 소스 작성을 통해 구현 방식을 분석하고 파악할 수 있다.



#### IT 산업을 이루는 제반 기술의 세부 구현 방식을 알 수 있다



파일 시스템, 메모리 관리, 네트워크, 이더넷 등의 기술들을 커널에서 소스코드로 파악 할 수 있다.

---



## 운영체제란?

> 운영체제는 하드웨어와 응용프로그램 사이에 있는 계층



**운영체제는 세부 하드웨어를 관리하는 역할을 수행한다.**

+ 운영체제는 하드웨어를 가상화 한다



**개발자가 작성하는 모든 코드를 실제로 실행하는 주체는 운영체제 커널이다.**

+ 유저 애플리케이션: 리눅스 표준 함수를 호출하면 시스템 콜을 통해 실제로 커널이 동작
+ 디바이스 드라이버: 디바이스 드라이버는 커널이 제공하는 함수를 사용하므로 실제 커널이 동작





---

## 리눅스의 역사



#### 멀틱스 운영체제

> 예전에는 read mode로 physical memory에 직접 프로그램을 올려 한번에 하나의 프로그램만 로드가 가능
>
> 시간이 흘러 한개 이상의 프로그램을 실행할 수 있는 수준으로 컴퓨팅 속도가 빨라져 새로운 소프트웨어를 
>
> 만들어 보려는 시도를 하게되는데 이 프로젝트가 유닉스의 모태가 되는 멀틱스 운영체제



1965년 MIT, AT&T 벨 연구소, 제네럴 일렉트릭 소속 개발자들이 모여 개발 시작

멀틱스 운영체제는 좌초됐지만

멀티태스킹과 멀티 유저를 지원하는 운영체제를 목표로 켄 톰슨과 다른 개발자들이 지속적으로 연구해

**유닉스(UNIX)** 가 탄생하게 된다.

한계는 아래와 같다

+ 어셈블리어로 구현해 이식성이 떨어져 PDP-7 이란 소형 컴퓨터에서만 실행가능 했다
+ 다른 기종의 CPU가 탑재된 컴퓨터에서 유닉스를 사용하려면 새롭게 코드를 작성해 구현해야 했다



유닉스의 호환성 문제를 개선하고자 데니스 리치가 C 언어를 개발하게 된다

1973년 유닉스를 C언어로 작성해 새로운 버전의 유닉스를 개발해 최초의 유닉스가 탄생하게 된다



#### 유닉스가 빠른 속도로 완성도가 높아진 이유

+ 유닉스는 오픈소스로 무료로 대학기관이나 연구소에 배포했다.
+ C 언어의 도입으로 유닉스의 이식성과 호환성을 높였다

이에 유닉스는 Berkeley Unix; BSD, SYSV 계열로 분화되어 다양한 유닉스 계열 운영체제가 사용되고 있다



#### GNU 단체 설립

AT&T가 반독점 소송으로 컴퓨터 사업에서 철수하게 되어 유닉스를 판매하게 된다.

이때 등장한게 **POSIX**

여러 회사에 UNIX를 팔다보니 유닉스의 표준의 필요성이 생겨 POSIX라는 규격이 만들어지게 된다

이때부터 유닉스 벤더들은 POSIX 규약에 맞춰 호환성을 유지한 유닉스 제품을 개발하게 된다.



##### 대학과 연구기관의 반발

더 이상 무료로 유닉스 소스코드를 볼 수 없게 되자 유료화에 반기를 들고 무료 버전의 유닉스를 개발하자는 목표로 

리처드 스톨만을 중심으로 **GNU(GNU is not UNIX)** 라는 단체를 설립하게 된다



GNU가 FSF(Free Software Foundation) 재단을 설립하며 무료 유닉스 개발에 들어간다



US 버클리에 속한 **BSD(Berkely Software Distribution) ** 개발자들이 기존의 유닉스 코들르 재해석해서 무료 유닉스를 완성하기도 했다 



#### 리누스 토발즈

필란드 헬싱키 대학에 재학 중이던 토발즈가 GNU 시스템에 적합한 커널을 직접 개발해 올린다.

0.02 공식 버전에서는 BASH(GNU Bourne Again Shell), GCC(GNU C Compiler) 정도만 실행 가능한 수준이였으나

0.95버전이 되자 인텔 x86 칩에서 그래픽 사용자 인터페이스를 추가하기에 이른다

스톨만과 FSF가 GNU 커널로 해당 커널을 채택하며 완성된 구조를 이루게 된다



---



## 리눅스가 널리 쓰이게 된 이유



+ **소스코드가 공개되어 있다**

  커널은 물론 리눅스를 구성하는 유틸리티 프로그램은 오픈소스이므로 모든 개발자가 같은 조건에서 리눅스를 익힐 수 있다

+ **개방적인 오픈소스 프로젝트**

  누구나 리눅스 프로젝트에 참여해 자신이 작성한 코드를 배포할 수 있다

+ **리눅스 커뮤니티**

  리눅스는 각 기능마다 메일링 리스트를 통해 전 세계 개발자들이 패치를 제안하며 논의한다

+ **다양한 CPU 아키텍쳐를 지원**

  다양한 CPU 아키텍처를 지원하도록 설계돼 있어, CPU 아키텍처에 맞춰 리눅스를 빌드하면 리눅스를 실행할 수 있다





### 리눅스의 쓰임



+ **안드로이드**

  리눅스커널은 스마트폰의 주력 운영체제로 사용하고 있다

+ **자동차(Auto Motive)**

  전기자동차 시장이 열리면서 지동차 인포테인먼트(infotainment) 분야에 리눅스 커널이 활발히 쓰이고 있다

+ **IoT(Internet of Things) 디바이스**

  대부분의 IoT 및 임베디드 디바이스는 다양한 리눅스 상에서 구현되고 있다.

  인텔이나 엔비다아, 퀄컴 같은 대형 SoC(System on Chip; apple M1 이 대표적) 벤더들도 IoT 시장에 뛰어들고 있다

---



## 임베디드 리눅스 개발 단체



### 리눅스 커널 커뮤니티

대부분 리눅스 커널 코드는 리눅스 커널 커뮤니티에서 만들어진다. 

리눅스 커널 커뮤니티는 리눅스 커널 개발의 심장으로서, 리눅스 커널 자체의 알고리즘을 비롯해 논리적 오류, 문제점을 개선하는 패치를 논의하고 관리한다.



- 버그 수정 패치
- 코드 리팩터링
- 신규 알고리즘
- 문서화



보통 2주 간격으로 그렉 크로아 하트만 이라는 개발자가 메일로 전 세계 개발자들에게 패치 반영 사실을 통지한다

리눅스 커널 버전과 코드 내역은 리눅스 커널 아카이브(https://www.kernel.org/) 사이트에서 확인 가능하다.



리눅스 커널 커뮤니티에서 관리하는 안정화된 리눅스 커널 버전을 LTS(Long Term Support) 라고 부른다.

최신 리눅스 커널 버전에 적용된 버그 수정패치는 LTS 리눅스 커널 버전에 꾸준히 반영된다



SoC 업체들은 대부분 LTS 리눅스 커널 버전을 선택해 개발한다.



---



## CPU 벤더

> 리눅스 커널과 관련된 주요 단체로 CPU 벤더가 있다
>
> CPU 벤더는 CPU를 설계하는 회사를 뜻한다



+ ARM(ARMv7/ARMv8)
+ 인텔(x86)
+ IBM(PowerPC)



CPU 벤더도 리눅스 커널 개발에 참여한다. 

아래와 같은 리눅스 커널의  핵심 기능은 CPU에 따라 구현 방식이 다르다

+ 시스템 콜
+ 익셉션
+ 컨텍스트 스위칭



리눅스 커널의 핵심 동작은 서로 다른 CPU 어셈블리 코드로 구현돼 있다

리눅스 커널은 다양한 아키텍쳐를 지원하는 소스 트리를 갖추고 있기에 해당 CPU 아키텍처에 맞게 빌드하면 이에 맞는 커널 이미지를 생성할 수 있다.



---

## SoC 벤더

> System-on-chip 의 약자로 컴퓨터 구성 요소를 통합한 집적회로를 의미한다
>
> 브로드컴, 삼성전자, 퀄컴, 인텔, 미디어텍, 엔비디아 같은 회사를 SoC 벤더라고 한다



이들은 먼저 리눅스 커널 버전을 선택하고 CPU 벤더로부터 툴 체인을 받아 자신의 SoC 스펙에 맞게 커널 코드를 수정하거나 드라이버를 추가한다

> Tool Chain이란 소프트웨어 개발에 사용되는 프로그래밍 도구의 집합이다. 대게 크로스 컴파일 환경을 뜻한다
>
> GNU로 예를 들자면
>
> + GNU GCC (compiler collection) : C와 C++ 컴파일러의 집합
> + GNU binary utilities: binutils - 어셈블러, loader, 기타 tools
> + GNU C library : glibc - 컴파일러 구축을 위한 라이브러리 및 일반 라이브러리



SoC 벤더에서 개발하는 대표적인 제품명은 아래와 같다

+ 브로드컴: BCM(bcm2837. 라즈베리 파이에 탑재)
+ 삼성전자(시스템 LSI): 엑시노스(Exynos)
+ 퀄컴: 스냅드래곤
+ 인텔: 아톰, 무어필드
+ 미디어텍: 헬리오
+ 엔비디아: 테그라



리눅스 커널을 사용해 SoC 하드웨어를 제어하는 디바이스 드라이버를 작성한다

> 엔비디아 SoC와 퀄컴 SoC 의 CPU(Graphic Processing Unit)는 자사의 SoC 하두웨어에 맞게 설계되어 있으니
>
> 서로 다른 디바이스 드라이버가 있는 것



---

## 보드벤더 및 OEM 

> 보드벤더와 OEM(Original Equipment Manufacturer) 업체는 SoC가 릴리즈한 리눅스 커널 코드를 받아 제품 스펙과 시나리오에 맞게 제품을 개발한다.



##### 보드 벤더와 OEM

보드 벤더는 라즈베리 파이 재단과 같은 업체이고 OEM은 삼성전자, LG전자와 같이 상용 제품을 개발하는 업체를 뜻함



라즈베리파이를 통해 예시를 들자면

* 라즈베리 파이는 BCM2837이라는 SoC를 탑재한 교육용 보드이며 라즈베리 파이 재단에서 개발한다.

* 보드 벤더인 라즈베리 파이 재단은 SoC 벤더인 브로드컴이 릴리스한 리눅스 커널 코드를 받아 라즈베리 파이의 스펙과 시나리오에 맞게 범용 보드로 개발해서 판다



많은 개발자들은 이 단계에서 SoC에서 제작한 **리눅스 드라이버 코드(리눅스 커널 + SoC 드라이버)** 를 받아 임베디드 리눅스를 개발한다.

즉, 제품마다 다양한 시나리오와 컨셉이 있을 건데 보드 벤더 및 OEM 개발자들은 제품 컨셉이 카메라면 카메라 센서를 제어하는 드라이버를 개발할 것이다.



보드 벤더와 OEM 개발자들은 이 과정에서 SoC 업체와 협업할 때가 많다. 

SoC 벤더에서 작성한 드라이버에서 버그를 확인하면 보드 벤더 및 OEM 업체는 버그를 리포트하고 개선 패치를 받아 수정



SoC 벤더에서 작성한 드라이버에 있는 버그를 보드벤더 및 OEM 의 개발자가 직접 수정할 수 도 있다

SoC 벤더에서 작성한 드라이버 코드는 리눅스 커널 소스코드와 함께 배포되기에 개발자가 아니더라도 소스코드를 열어 볼 수 있는 것.



---



## 임베디드 리눅스 개발을 잘 하려면?



리눅스 개발자가 알아야할 지식은

+ 디바이스 드라이버
+ 리눅스 커널
+ CPU 아키텍쳐
+ SoC



넓게 본다면

+ 유저 공간 HAL(Hardware Abstraction Layer) 코드 구현 
+ 빌드 스크립트 구현
+ 테스트용 디바이스 드라이버 구현
+ Git 과 형상관리



---



## 디바이스 드라이버

> 디바이스 드라이버의 시나리오와 제어하는 하드웨어의 종류는 다양하지만 다음 내용 정도는 알아야 한다

+ 인터럽트 핸들러 함수와 인터럽트를 처리하는 방식
+ 디바이스 파일로 open/read/write 연산에 대한 함수를 등록하는 방법
+ 디바이스 트리를 읽어 디바이스 속성을 저장하는 방식



## 리눅스 커널

> 디바이스 드라이버는 리눅스 커널에서 제공하는 함수로 구성되어 있다.
>
> 호출한 함수의 동작 방식을 알려면 리눅스 커널 코들르 분석할 수밖에 없다
>
> 리눅스 디바이스 드라이버는 리눅스 커널 그 자체라고 할 수도 있다

디바이스 드라이버는 구현 뿐만 아니라 QA 부서를 통해 드라이버 안정화 테스트 과정을 거쳐야 한다.

이 과정에서 만나는 다양한 버그나 문제증상이 리포트되는데 다양한 버그를 수정해 문제를 해결하기 위해서는

**리눅스 커널에 깊이있는 이해가 필요하다.**



## CPU 아키텍쳐

> 리눅스 커널 코드에는 어셈블리 코드가 있다.

리눅스 커널의 핵심 개념들은 대부분 어셈블리 코드로 구현돼 있다. 

그 이유는 리눅스 커널의 핵심 동작은 CPU 아키텍처와 연관된 부분이 많기 때문이다.

+ 컨텍스트 스위칭
+ 익셉션 벡터
+ 시스템 콜
+ 시그널 핸들러
+ 메모리 관리(MMU)



**CPU 아케텍처의 세부 동작 원리와 어셈블리 코드는 어렵기에 리눅스 시스템과 커널 로그, ftrace가 먼저다**

하지면 알면 좋다

+ 어셈블리 언어 
+ 익셉션이 발생하는 원리와 익셉션 벡터의 세부 동작
+ 함수 호출 규약(Calling Convention)





---



## 라즈베리 파이와 리눅스 커널



#### 라즈베리 파이 실습 보드 스펙

> 라즈베리 파이 3 모델 B

**하드웨어 스펙**

+ SoC: Broadcom BCM2837 SoC
+ CPU: 1.2GHz ARM Cortex-A53 MP4
+ GPU: Broadcom VideoCore IV MP2 400 MHz
+ Memory:  1GB LPDDR2
+ SD 카드: Micro SD, push-pull type



### 리눅스 커널 버전

> 4.19 버전 사용 
>
> https://github.com/raspberrypi/linux/tree/rpi-4.19.y

라즈비안 전용 디바이스 드라이버를 제외하고 리눅스 커뮤니티 소스와 99% 동일

리눅스 커널 커뮤니티에서 관리하는 커널 코드

+ https://elixir.bootlin.com/linux/v4.19.30/source



#### ARM 아키텍처

라즈베리 파이 3 모델 B는 ARMv7 아키텍처를 기반으로 동작



